// Generated by CoffeeScript 2.6.1
(function() {
  var CoffeeScript, Module, binary, cacheSourceMaps, child_process, ext, findExtension, fork, formatSourcePosition, getRootModule, getSourceMap, helpers, i, len, loadFile, nodeSourceMapsSupportEnabled, path, ref, ref1, registerCompiled;

  CoffeeScript = require('./');

  child_process = require('child_process');

  helpers = require('./helpers');

  path = require('path');

  ({getSourceMap, registerCompiled} = require("./sourcemap"));

  // Check if Node's built-in source map stack trace transformations are enabled.
  nodeSourceMapsSupportEnabled = process.execArgv.includes('--enable-source-maps') || ((ref = process.env.NODE_OPTIONS) != null ? ref.includes('--enable-source-maps') : void 0);

  if (!(Error.prepareStackTrace || nodeSourceMapsSupportEnabled)) {
    cacheSourceMaps = true;
    // Based on http://v8.googlecode.com/svn/branches/bleeding_edge/src/messages.js
    // Modified to handle sourceMap
    formatSourcePosition = function(frame, getSourceMapping) {
      var as, column, fileLocation, filename, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
      filename = void 0;
      fileLocation = '';
      if (frame.isNative()) {
        fileLocation = "native";
      } else {
        if (frame.isEval()) {
          filename = frame.getScriptNameOrSourceURL();
          if (!filename) {
            fileLocation = `${frame.getEvalOrigin()}, `;
          }
        } else {
          filename = frame.getFileName();
        }
        filename || (filename = "<anonymous>");
        line = frame.getLineNumber();
        column = frame.getColumnNumber();
        // Check for a sourceMap position
        source = getSourceMapping(filename, line, column);
        fileLocation = source ? `${filename}:${source[0]}:${source[1]}` : `${filename}:${line}:${column}`;
      }
      functionName = frame.getFunctionName();
      isConstructor = frame.isConstructor();
      isMethodCall = !(frame.isToplevel() || isConstructor);
      if (isMethodCall) {
        methodName = frame.getMethodName();
        typeName = frame.getTypeName();
        if (functionName) {
          tp = as = '';
          if (typeName && functionName.indexOf(typeName)) {
            tp = `${typeName}.`;
          }
          if (methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1) {
            as = ` [as ${methodName}]`;
          }
          return `${tp}${functionName}${as} (${fileLocation})`;
        } else {
          return `${typeName}.${methodName || '<anonymous>'} (${fileLocation})`;
        }
      } else if (isConstructor) {
        return `new ${functionName || '<anonymous>'} (${fileLocation})`;
      } else if (functionName) {
        return `${functionName} (${fileLocation})`;
      } else {
        return fileLocation;
      }
    };
    // Based on [michaelficarra/CoffeeScriptRedux](http://goo.gl/ZTx1p)
    // NodeJS / V8 have no support for transforming positions in stack traces using
    // sourceMap, so we must monkey-patch Error to display CoffeeScript source
    // positions.
    Error.prepareStackTrace = function(err, stack) {
      var frame, frames, getSourceMapping;
      getSourceMapping = function(filename, line, column) {
        var answer, sourceMap;
        sourceMap = getSourceMap(filename, line, column);
        if (sourceMap != null) {
          answer = sourceMap.sourceLocation([line - 1, column - 1]);
        }
        if (answer != null) {
          return [answer[0] + 1, answer[1] + 1];
        } else {
          return null;
        }
      };
      frames = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = stack.length; i < len; i++) {
          frame = stack[i];
          if (frame.getFunction() === exports.run) {
            break;
          }
          results.push(`    at ${formatSourcePosition(frame, getSourceMapping)}`);
        }
        return results;
      })();
      return `${err.toString()}\n${frames.join('\n')}\n`;
    };
  }

  // Load and run a CoffeeScript file for Node, stripping any `BOM`s.
  loadFile = function(module, filename) {
    var js, options, sourceMap;
    options = module.options || getRootModule(module).options;
    // We may need to cache our own sourcemaps to transform stack traces.
    if (cacheSourceMaps) {
      options.sourceMap = true;
      ({js, sourceMap} = CoffeeScript._compileFile(filename, options));
      // TODO may be redundant
      registerCompiled(filename, null, sourceMap);
    } else {
      if (nodeSourceMapsSupportEnabled) {
        options.inlineMap = true;
      }
      js = CoffeeScript._compileFile(filename, options);
    }
    return module._compile(js, filename);
  };

  // If the installed version of Node supports `require.extensions`, register
  // CoffeeScript as an extension.
  if (require.extensions) {
    ref1 = CoffeeScript.FILE_EXTENSIONS;
    for (i = 0, len = ref1.length; i < len; i++) {
      ext = ref1[i];
      require.extensions[ext] = loadFile;
    }
    // Patch Node's module loader to be able to handle multi-dot extensions.
    // This is a horrible thing that should not be required.
    Module = require('module');
    findExtension = function(filename) {
      var curExtension, extensions;
      extensions = path.basename(filename).split('.');
      if (extensions[0] === '') {
        // Remove the initial dot from dotfiles.
        extensions.shift();
      }
      // Start with the longest possible extension and work our way shortwards.
      while (extensions.shift()) {
        curExtension = '.' + extensions.join('.');
        if (Module._extensions[curExtension]) {
          return curExtension;
        }
      }
      return '.js';
    };
    Module.prototype.load = function(filename) {
      var extension;
      this.filename = filename;
      this.paths = Module._nodeModulePaths(path.dirname(filename));
      extension = findExtension(filename);
      Module._extensions[extension](this, filename);
      return this.loaded = true;
    };
  }

  // If we're on Node, patch `child_process.fork` so that Coffee scripts are able
  // to fork both CoffeeScript files, and JavaScript files, directly.
  if (child_process) {
    ({fork} = child_process);
    binary = require.resolve('../../bin/coffee');
    child_process.fork = function(path, args, options) {
      if (helpers.isCoffee(path)) {
        if (!Array.isArray(args)) {
          options = args || {};
          args = [];
        }
        args = [path].concat(args);
        path = binary;
      }
      return fork(path, args, options);
    };
  }

  // Utility function to find the `options` object attached to the topmost module.
  getRootModule = function(module) {
    if (module.parent) {
      return getRootModule(module.parent);
    } else {
      return module;
    }
  };

}).call(this);
